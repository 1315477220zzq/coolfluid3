// OpenCL Kernel
char* GPUSource =
{
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable \n"
"    void AtomicAdd(__global float *val, const float delta )                                                \n"
"    {                                                                                                      \n"
"        union { float f; unsigned int i; } oldVal;                                                         \n"
"        union { float f; unsigned int i; } newVal;                                                         \n"
"                                                                                                           \n"
"        do                                                                                                 \n"
"        {                                                                                                  \n"
"            oldVal.f = *val;                                                                               \n"
"            newVal.f = oldVal.f + delta;                                                                   \n"
"        }                                                                                                  \n"
"        while (atom_cmpxchg((__global unsigned int *)val, oldVal.i, newVal.i) != oldVal.i);                \n"
"    }                                                                                                      \n"
"    __kernel void interpolation(__global float* phi, __global float* waveSpeed,                            \n"
"                                __global float* A_inter, __global float* A_ksi, __global float* A_eta,     \n"
"                                __global float* weights,                                                   \n"
"                                __global float* X_node, __global float* U_node,                            \n"
"                                __global Uint* connectTable,                                               \n"
"                                int shape, int quad, int dim, int elem, int nEq,                           \n"
"                                __local float* X_shape,  __local float* U_shape,                           \n"
"                                __local float* X_quad,   __local float* X_ksi, __local float* X_eta,       \n"
"                                __local float* U_quad,   __local float* jq,    __local float* Rv,          \n"
"                                __local float* Lv,       __local float* Dv,    __local float* Af,          \n"
"                                __local float* Bf,       __local float* Ki,    __local float* invKi,       \n"
"                                __local float* sumLplus, __local float* dudx,  __local float* dudy,        \n"
"                                __local float* LU,       __local float* LUwq,  __local float* help,        \n"
"                                __local float* phiH,     __local float* phiHN, __local float* wS )         \n"
"    {                                                                                                      \n"
"     for( unsigned int tx = get_group_id(0); tx < elem; tx+= get_num_groups(0) )                           \n"
"     {                                                                                                     \n"
"        // connection data from the table to the real element                                              \n"
"                                                                                                           \n"
"        for(unsigned int j = get_local_id(0);j< shape;j+= get_local_size(0))                               \n"
"        {                                                                                                  \n"
"                       Uint adress = connectTable[ tx * shape + j ];                                       \n"
"                       for( unsigned int k = 0; k < dim; k++)                                              \n"
"                       {                                                                                   \n"
"                           X_shape[ j*dim + k] = X_node[ adress*dim + k ];                                 \n"
"                       }                                                                                   \n"
"                       for( unsigned int k = 0; k < nEq; k++)                                              \n"
"                       {                                                                                   \n"
"                           U_shape[ j*nEq + k] = U_node[ adress*nEq + k ];                                 \n"
"                       }                                                                                   \n"
"        }                                                                                                  \n"
"                                                                                                           \n"
"       //  interpolation data from shape to quadreture points                                              \n"
"                                                                                                           \n"
"                                                                                                           \n"
"        float gamma = 1.4;                                                                                 \n"
"        float R = 287.058;                                                                                 \n"
"                                                                                                           \n"
"        for(unsigned int j =get_local_id(0);j< quad;j+= get_local_size(0) )                                \n"
"        {                                                                                                  \n"
"           for( unsigned int k = 0; k < dim; k++ )                                                         \n"
"           {                                                                                               \n"
"                unsigned int elemC =  j * dim + k;                                                         \n"
"                                                                                                           \n"
"                float value = 0.0;                                                                         \n"
"                float value1 = 0.0;                                                                        \n"
"                float value2 = 0.0;                                                                        \n"
"                                                                                                           \n"
"                for( unsigned int l = 0; l < shape; l++ )                                                  \n"
"                {                                                                                          \n"
"                    unsigned int elemA = j * shape + l;                                                    \n"
"                    unsigned int elemB = l * dim + k;                                                      \n"
"                                                                                                           \n"
"                    value += A_inter[elemA] * X_shape[elemB];                                              \n"
"                    value1 += A_ksi[elemA] * X_shape[elemB];                                               \n"
"                    value2 += A_eta[elemA] * X_shape[elemB];                                               \n"
"                }                                                                                          \n"
"                X_quad[elemC] = value;                                                                     \n"
"                X_ksi[elemC] =  value1;                                                                    \n"
"                X_eta[elemC] =  value2;                                                                    \n"
"           }                                                                                               \n"
"                                                                                                           \n"
"           jq[j] = X_ksi[j * dim] * X_eta[j*dim+1] - X_ksi[j * dim+1] * X_eta[j*dim];                      \n"
"        }                                                                                                  \n"
"        for(unsigned int j =get_local_id(0);j< quad;j+= get_local_size(0) )                                \n"
"        {                                                                                                  \n"
"                                                                                                           \n"
"                                                                                                           \n"
"           for( unsigned int k = 0; k < nEq; k++ )                                                         \n"
"           {                                                                                               \n"
"                unsigned int elemC =  j * nEq + k;                                                         \n"
"                                                                                                           \n"
"                float value = 0.0;                                                                           \n"
"                                                                                                           \n"
"                for( unsigned int l = 0; l < shape; l++ )                                                  \n"
"                {                                                                                          \n"
"                    unsigned int elemA = j * shape + l;                                                    \n"
"                    unsigned int elemB = l * nEq + k;                                                      \n"
"                                                                                                           \n"
"                    value += A_inter[elemA] * U_shape[elemB];                                              \n"
"                }                                                                                          \n"
"                U_quad[elemC] = value;                                                                     \n"
"           }                                                                                               \n"
"        }                                                                                                  \n"
"        for(unsigned int j =get_local_id(0);j< quad;j+= get_local_size(0) )                                \n"
"        {                                                                                                  \n"
"           // set matrix Ki                                                                                \n"
"                                                                                                           \n"
"           // compute properties                                                                           \n"
"                                                                                                           \n"
"           float rho = U_quad[j*nEq];                                                                      \n"
"           float rhoU = U_quad[j*nEq + 1];                                                                 \n"
"           float rhoV = U_quad[j*nEq + 2];                                                                 \n"
"           float rhoE = U_quad[j*nEq + 3];                                                                 \n"
"           float u = rhoU / rho;                                                                           \n"
"           float v = rhoV / rho;                                                                           \n"
"           float uuvv = u*u + v*v;                                                                         \n"
"           float H = gamma * rhoE / rho - 0.5 * (gamma-1.0) * uuvv;                                        \n"
"           float a = sqrt((gamma-1.0)*(H-0.5*uuvv));                                                       \n"
"           float T = a*a/(gamma*R);                                                                        \n"
"           float p = rho * R * T;                                                                          \n"
"           float E  = H-p / rho;                                                                           \n"
"           float half_gm1_v2 = 0.5 * (gamma - 1.0 ) * uuvv;                                                \n"
"                                                                                                           \n"
"           int adressQ = j*nEq*nEq;                                                                        \n"
"           int adressDer = j*nEq;                                                                          \n"
"           for( int k = 0; k < 16; k++ )                                                                   \n"
"           {                                                                                               \n"
"               sumLplus[adressQ+k] = 0.0;                                                                    \n"
"           }                                                                                               \n"
"           for( int k = 0; k < nEq; k++)                                                                   \n"
"           {                                                                                               \n"
"               dudx[adressDer + k] = 0.0;                                                                  \n"
"               dudy[adressDer + k] = 0.0;                                                                  \n"
"                                                                                                           \n"
"           }                                                                                               \n"
"                                                                                                           \n"
"           for( int k = 0; k < shape; k++ )                                                                \n"
"           {                                                                                               \n"
"               int adressQS = (j*shape+k)*nEq*nEq;                                                         \n"
"               unsigned int elemMatrix = j * shape + k;                                                    \n"
"               unsigned int elemA      = j * dim;                                                          \n"
"                                                                                                           \n"
"               float nx =  ( A_ksi[elemMatrix] * X_eta[elemA+1] - A_eta[elemMatrix] * X_ksi[elemA+1])/jq[j];//gradX \n"
"               float ny = (-A_ksi[elemMatrix] * X_eta[elemA] + A_eta[elemMatrix] * X_ksi[elemA])/jq[j];//gradY     \n"
"                                                                                                           \n"
"               for( int l = 0; l < nEq; l++ )                                                              \n"
"               {                                                                                           \n"
"                   unsigned int elemB = k * nEq + l;                                                       \n"
"                   dudx[adressDer + l] += nx*U_shape[elemB];                                               \n"
"                   dudy[adressDer + l] += ny*U_shape[elemB];                                               \n"
"               }                                                                                           \n"
"                                                                                                           \n"
"               float um = u * nx + v * ny;                                                                 \n"
"               float ra = 0.5 * rho / a;                                                                   \n"
"               float coeffM2 = half_gm1_v2 / (a*a);                                                        \n"
"               float uDivA = (gamma -1.0) * u / a;                                                           \n"
"               float vDivA = (gamma -1.0) * v / a;                                                           \n"
"               float gm1_ov_rhoa = (gamma -1.0) / a;                                                         \n"
"                                                                                                           \n"
"               Rv[adressQ]    = 1.0;      Rv[adressQ+1]  = 0.0;             Rv[adressQ+2]  = ra;            Rv[adressQ+3]  = ra;                                      \n"
"               Rv[adressQ+4]  = u;        Rv[adressQ+5]  = rho*ny;          Rv[adressQ+6]  = ra * (u+a*nx); Rv[adressQ+7]  = ra * (u-a*nx);                           \n"
"               Rv[adressQ+8]  = v;        Rv[adressQ+9]  = -rho*nx;         Rv[adressQ+10] = ra * (v+a*ny); Rv[adressQ+11] = ra * (v-a*ny);                           \n"
"               Rv[adressQ+12] = 0.5*uuvv; Rv[adressQ+13] = rho*(u*ny-v*nx); Rv[adressQ+14] = ra * (H+a*um); Rv[adressQ+15] = ra * (H-a*um);                           \n"
"                                                                                                                                                                      \n"
"               Lv[adressQ]    = 1.0-coeffM2;                  Lv[adressQ+1]  = uDivA / a;        Lv[adressQ+2]  = vDivA / a;        Lv[adressQ+3] = -(gamma-1.0)/(a*a);  \n"
"               Lv[adressQ+4]  = ( v*nx-u*ny ) / rho;          Lv[adressQ+5]  = ny/rho;           Lv[adressQ+6]  = -nx / rho;        Lv[adressQ+7] = 0.0;              \n"
"               Lv[adressQ+8]  = a / rho * (coeffM2 - um / a); Lv[adressQ+9]  = (nx-uDivA) / rho; Lv[adressQ+10] = (ny-vDivA) / rho; Lv[adressQ+11] = gm1_ov_rhoa;     \n"
"               Lv[adressQ+12] = a / rho * (coeffM2 + um / a); Lv[adressQ+13] = -(nx+uDivA) / rho; Lv[adressQ+14] = -(ny+vDivA) / rho; Lv[adressQ+15] = gm1_ov_rhoa;     \n"
"                                                                                                                                                    \n"
"               if(um>0.0){Dv[j*nEq]=um;Dv[j*nEq+1]=um;}else{Dv[j*nEq]=0.0;Dv[j*nEq+1]=0.0;}                                                               \n"
"               if(um+a>0.0){Dv[j*nEq+2]=um+a;}else{Dv[j*nEq+2]=0.0;}                                                                                    \n"
"               if(um-a>0.0){Dv[j*nEq+3]=um-a;}else{Dv[j*nEq+3]=0.0;}                                                                                    \n"
"                                                                                                                                                    \n"
"                                                                                                                                                    \n"
"                                                                                                                                                    \n"
"               for( int l = 0; l < nEq*nEq; l++ )                                                                                                   \n"
"                   Ki[adressQS+l] = 0.0;                                                                                                              \n"
"               for( int l = 0; l < nEq; l++ )                                                                                                       \n"
"                  for( int m = 0; m < nEq; m++ )                                                                                                    \n"
"                     for( int n = 0; n < nEq; n++ )                                                                                                 \n"
"                           Ki[adressQS+l*nEq+m] += Rv[adressQ+l*nEq+n ] * Dv[j*nEq+n] * Lv[adressQ+m+n*nEq ];                                       \n"
"               for( int l = 0; l < nEq*nEq; l++ )                                                                                                   \n"
"                   sumLplus[adressQ+l] += Ki[adressQS+l];                                                                                           \n"
"                                                                                                                                                    \n"
"               float ax; if (Dv[j*nEq]>= Dv[j*nEq+1]) {ax = Dv[j*nEq];} else {ax = Dv[j*nEq+1];}                                                     \n"
"               float bx; if (Dv[j*nEq]>= Dv[j*nEq+1]) {bx = Dv[j*nEq+2];} else {bx = Dv[j*nEq+3];}                                                   \n"
"               if (ax>= bx) {wS[j*shape+k]=ax* weights[j] *jq[j];} else {wS[j*shape+k]=bx* weights[j] *jq[j];}                           \n"
"               //unsigned int elemC = connectTable[ tx * shape + k ]; AtomicAdd( &waveSpeed[elemC], wave_speed );                                   \n"
"               //  unsigned int elemC = connectTable[ tx * shape + k ]; waveSpeed[elemC] += wave_speed;                                                 \n"
"            }                                                                                                                                       \n"
"                                                                                                                                                    \n"
"           float detKi = sumLplus[adressQ]  *(sumLplus[adressQ+5]*sumLplus[adressQ+10]*sumLplus[adressQ+15] + sumLplus[adressQ+6]*sumLplus[adressQ+11]*sumLplus[adressQ+13] + sumLplus[adressQ+7]*sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+5]*sumLplus[adressQ+11]*sumLplus[adressQ+14] - sumLplus[adressQ+6]*sumLplus[adressQ+9] *sumLplus[adressQ+15] - sumLplus[adressQ+7]*sumLplus[adressQ+10]*sumLplus[adressQ+13] )  \n"
"                       + sumLplus[adressQ+1]*(sumLplus[adressQ+4]*sumLplus[adressQ+11]*sumLplus[adressQ+14] + sumLplus[adressQ+6]*sumLplus[adressQ+8] *sumLplus[adressQ+15] + sumLplus[adressQ+7]*sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+4]*sumLplus[adressQ+10]*sumLplus[adressQ+15] - sumLplus[adressQ+6]*sumLplus[adressQ+11]*sumLplus[adressQ+12] - sumLplus[adressQ+7]*sumLplus[adressQ+8] *sumLplus[adressQ+14] )  \n"
"                       + sumLplus[adressQ+2]*(sumLplus[adressQ+4]*sumLplus[adressQ+9] *sumLplus[adressQ+15] + sumLplus[adressQ+5]*sumLplus[adressQ+11]*sumLplus[adressQ+12] + sumLplus[adressQ+7]*sumLplus[adressQ+8] *sumLplus[adressQ+13] - sumLplus[adressQ+4]*sumLplus[adressQ+11]*sumLplus[adressQ+13] - sumLplus[adressQ+5]*sumLplus[adressQ+8] *sumLplus[adressQ+15] - sumLplus[adressQ+7]*sumLplus[adressQ+9] *sumLplus[adressQ+12] )  \n"
"                       + sumLplus[adressQ+3]*(sumLplus[adressQ+4]*sumLplus[adressQ+10]*sumLplus[adressQ+13] + sumLplus[adressQ+5]*sumLplus[adressQ+8] *sumLplus[adressQ+14] + sumLplus[adressQ+6]*sumLplus[adressQ+9] *sumLplus[adressQ+12] - sumLplus[adressQ+4]*sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+5]*sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+6]*sumLplus[adressQ+8] *sumLplus[adressQ+13] ); \n"
"                                                                                                                                                                                                                                                                                                                                                                                                                                               \n"
"           invKi[adressQ]    = 1 / detKi * ( sumLplus[adressQ+5]*(sumLplus[adressQ+10]*sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+14]) + sumLplus[adressQ+6]*(sumLplus[adressQ+11]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+15]) + sumLplus[adressQ+7]*(sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+1]  = 1 / detKi * ( sumLplus[adressQ+1]*(sumLplus[adressQ+11]*sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+15]) + sumLplus[adressQ+2]*(sumLplus[adressQ+9] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+13]) + sumLplus[adressQ+3]*(sumLplus[adressQ+10]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+14]) );                                                        \n"
"           invKi[adressQ+2]  = 1 / detKi * ( sumLplus[adressQ+1]*(sumLplus[adressQ+6] *sumLplus[adressQ+15] - sumLplus[adressQ+7] *sumLplus[adressQ+14]) + sumLplus[adressQ+2]*(sumLplus[adressQ+7] *sumLplus[adressQ+13] - sumLplus[adressQ+5] *sumLplus[adressQ+15]) + sumLplus[adressQ+3]*(sumLplus[adressQ+5] *sumLplus[adressQ+14] - sumLplus[adressQ+6] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+3]  = 1 / detKi * ( sumLplus[adressQ+1]*(sumLplus[adressQ+7] *sumLplus[adressQ+10] - sumLplus[adressQ+6] *sumLplus[adressQ+11]) + sumLplus[adressQ+2]*(sumLplus[adressQ+5] *sumLplus[adressQ+11] - sumLplus[adressQ+7] *sumLplus[adressQ+9])  + sumLplus[adressQ+3]*(sumLplus[adressQ+6] *sumLplus[adressQ+9]  - sumLplus[adressQ+5] *sumLplus[adressQ+10]) );                                                        \n"
"           invKi[adressQ+4]  = 1 / detKi * ( sumLplus[adressQ+4]*(sumLplus[adressQ+11]*sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+15]) + sumLplus[adressQ+6]*(sumLplus[adressQ+8] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+12]) + sumLplus[adressQ+7]*(sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+14]) );                                                        \n"
"           invKi[adressQ+5]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+10]*sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+14]) + sumLplus[adressQ+2]*(sumLplus[adressQ+11]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+15]) + sumLplus[adressQ+3]*(sumLplus[adressQ+8] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+6]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+7] *sumLplus[adressQ+14] - sumLplus[adressQ+6] *sumLplus[adressQ+15]) + sumLplus[adressQ+2]*(sumLplus[adressQ+4] *sumLplus[adressQ+15] - sumLplus[adressQ+7] *sumLplus[adressQ+12]) + sumLplus[adressQ+3]*(sumLplus[adressQ+6] *sumLplus[adressQ+12] - sumLplus[adressQ+4] *sumLplus[adressQ+14]) );                                                        \n"
"           invKi[adressQ+7]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+6] *sumLplus[adressQ+11] - sumLplus[adressQ+7] *sumLplus[adressQ+10]) + sumLplus[adressQ+2]*(sumLplus[adressQ+7] *sumLplus[adressQ+8]  - sumLplus[adressQ+4] *sumLplus[adressQ+11]) + sumLplus[adressQ+3]*(sumLplus[adressQ+4] *sumLplus[adressQ+10] - sumLplus[adressQ+6] *sumLplus[adressQ+8]) );                                                         \n"
"           invKi[adressQ+8]  = 1 / detKi * ( sumLplus[adressQ+4]*(sumLplus[adressQ+9] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+13]) + sumLplus[adressQ+5]*(sumLplus[adressQ+11]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+15]) + sumLplus[adressQ+7]*(sumLplus[adressQ+8] *sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+9]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+11]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+15]) + sumLplus[adressQ+1]*(sumLplus[adressQ+8] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+12]) + sumLplus[adressQ+3]*(sumLplus[adressQ+9] *sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+10] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+5] *sumLplus[adressQ+15] - sumLplus[adressQ+7] *sumLplus[adressQ+13]) + sumLplus[adressQ+1]*(sumLplus[adressQ+7] *sumLplus[adressQ+12] - sumLplus[adressQ+4] *sumLplus[adressQ+15]) + sumLplus[adressQ+3]*(sumLplus[adressQ+4] *sumLplus[adressQ+13] - sumLplus[adressQ+5] *sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+11] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+7] *sumLplus[adressQ+9]  - sumLplus[adressQ+5] *sumLplus[adressQ+11]) + sumLplus[adressQ+1]*(sumLplus[adressQ+4] *sumLplus[adressQ+11] - sumLplus[adressQ+7] *sumLplus[adressQ+8])  + sumLplus[adressQ+3]*(sumLplus[adressQ+5] *sumLplus[adressQ+8]  - sumLplus[adressQ+4] *sumLplus[adressQ+9]) );                                                         \n"
"           invKi[adressQ+12] = 1 / detKi * ( sumLplus[adressQ+4]*(sumLplus[adressQ+10]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+14]) + sumLplus[adressQ+5]*(sumLplus[adressQ+8] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+12]) + sumLplus[adressQ+6]*(sumLplus[adressQ+9] *sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+13] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+13]) + sumLplus[adressQ+1]*(sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+14]) + sumLplus[adressQ+2]*(sumLplus[adressQ+8] *sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+14] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+6] *sumLplus[adressQ+13] - sumLplus[adressQ+5] *sumLplus[adressQ+14]) + sumLplus[adressQ+1]*(sumLplus[adressQ+4] *sumLplus[adressQ+14] - sumLplus[adressQ+6] *sumLplus[adressQ+12]) + sumLplus[adressQ+2]*(sumLplus[adressQ+5] *sumLplus[adressQ+12] - sumLplus[adressQ+4] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+15] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+5] *sumLplus[adressQ+10] - sumLplus[adressQ+6] *sumLplus[adressQ+9])  + sumLplus[adressQ+1]*(sumLplus[adressQ+6] *sumLplus[adressQ+8]  - sumLplus[adressQ+4] *sumLplus[adressQ+10]) + sumLplus[adressQ+2]*(sumLplus[adressQ+4] *sumLplus[adressQ+9]  - sumLplus[adressQ+5] *sumLplus[adressQ+8]) );                                                         \n"
"                                                                                                                                                     \n"
"           Af[adressQ]    = 0.0;                Af[adressQ+1]  = 1.0;               Af[adressQ+2]  = 0.0;            Af[adressQ+3] = 0.0;             \n"
"           Af[adressQ+4]  = half_gm1_v2 -u*u;   Af[adressQ+5]  = -(gamma - 3.0)*u;    Af[adressQ+6]  = -(gamma-1.0)*v;   Af[adressQ+7] =( gamma - 1.0 );   \n"
"           Af[adressQ+8]  = -u*v;               Af[adressQ+9]  = v;                 Af[adressQ+10] = u;              Af[adressQ+11] = 0.0;           \n"
"           Af[adressQ+12] = ( half_gm1_v2-H)*u; Af[adressQ+13] = -(gamma-1.0)*u*u +H; Af[adressQ+14] = -(gamma-1.0)*u*v; Af[adressQ+15] = gamma * u;     \n"
"                                                                                                                                                     \n"
"           Bf[adressQ]    = 0.0;                Bf[adressQ+1]  = 0.0;            Bf[adressQ+2]  = 1.0;               Bf[adressQ+3] = 0.0;            \n"
"           Bf[adressQ+4]  = -u*v;               Bf[adressQ+5]  = v;              Bf[adressQ+6]  = u;                 Bf[adressQ+7] = 0.0;            \n"
"           Bf[adressQ+8]  = half_gm1_v2 -v*v;   Bf[adressQ+9]  = -(gamma-1.0)*u;   Bf[adressQ+10] = -(gamma-3.0)*v;    Bf[adressQ+11] =( gamma - 1.0 );  \n"
"           Bf[adressQ+12] = ( half_gm1_v2-H)*v; Bf[adressQ+13] = -(gamma-1.0)*u*v; Bf[adressQ+14] = -(gamma-1.0)*v*v +H; Bf[adressQ+15] = gamma *v;      \n"
"                                                                                                                                                     \n"
"           for(int k = 0; k < nEq; k++ )                                                                      \n"
"           {                                                                                                  \n"
"               float aux = 0.0;                                                                               \n"
"               float buy = 0.0;                                                                               \n"
"                                                                                                              \n"
"               for( int l=0; l < nEq; l++ )                                                                   \n"
"               {                                                                                              \n"
"                   aux +=Af[adressQ+k*nEq+l]*dudx[adressDer+l];                                               \n"
"                   buy +=Bf[adressQ+k*nEq+l]*dudy[adressDer+l];                                               \n"
"               }                                                                                              \n"
"                                                                                                              \n"
"               LU[j*nEq+k] = aux+buy;                                                                         \n"
"           }                                                                                                  \n"
"                                                                                                              \n"
"           for(int k = 0; k < nEq; k++ )                                                                      \n"
"           {                                                                                                  \n"
"               float a = 0.0;                                                                                 \n"
"                                                                                                              \n"
"               for( int l=0; l < nEq; l++ )                                                                   \n"
"                  a +=invKi[adressQ+k*nEq+l]*LU[adressDer+l]*weights[j]*jq[j];                                \n"
"               LUwq[j*nEq+k] = a;                                                                             \n"
"           }                                                                                                  \n"
"                                                                                                              \n"
"           for(int k = 0; k < shape; k++ )                                                                    \n"
"           {                                                                                                  \n"
"                                                                                                              \n"
"               int adressQS = (j*shape+k)*nEq*nEq;                                                            \n"
"               for( int l=0; l < nEq; l++ )                                                                   \n"
"               {                                                                                              \n"
"                   float a = 0.0;                                                                             \n"
"                   unsigned int elemC = connectTable[ tx * shape + k ]*nEq+l;                                 \n"
"                   for( int m = 0; m < nEq; m++ )                                                             \n"
"                       a +=Ki[adressQS+l*nEq+m]*LUwq[j*nEq+m];                                                \n"
"                   phiH[(j*shape+k)*nEq+l]=a;                                                                 \n"
"               }                                                                                              \n"
"                                                                                                              \n"
"           }                                                                                                  \n"
"                                                                                                              \n"
"           // N disipation                                                                                    \n"
"                                                                                                              \n"
"           for(int k = 0; k<shape;k++)                                                                        \n"
"           {                                                                                                  \n"
"              for( int m = 0; m < nEq; m++ )                                                                  \n"
"                   LUwq[adressDer+m] = 0.0;                                                                   \n"
"                                                                                                              \n"
"               for(int m = 0; m < shape; m++ )                                                                \n"
"               {                                                                                              \n"
"                   int adressQS = (j*shape+m)*nEq*nEq;                                                        \n"
"                   if( k != m )                                                                               \n"
"                   {                                                                                          \n"
"                       for( int n = 0; n<nEq; n++)                                                            \n"
"                       {                                                                                      \n"
"                           float a = 0.0;                                                                     \n"
"                           for(int o = 0; o<nEq; o++)                                                         \n"
"                              a+=Ki[adressQS+n*nEq+o]*(U_shape[ k*nEq + o] - U_shape[ m*nEq + o]);            \n"
"                           LUwq[adressDer+n] += a;                                                            \n"
"                       }                                                                                      \n"
"                   }                                                                                          \n"
"               }                                                                                              \n"
"                                                                                                              \n"
"               for( int l = 0; l < nEq; l++ )                                                                 \n"
"               {                                                                                              \n"
"                   float a =0.0;                                                                              \n"
"                                                                                                              \n"
"                   for(int m = 0; m<nEq;m++)                                                                  \n"
"                       a += invKi[adressQ + l* nEq+m]*LUwq[adressDer+m]*weights[j]*jq[j];                     \n"
"                   help[adressDer+l] =a;                                                                      \n"
"               }                                                                                              \n"
"               for( int l = 0; l < nEq; l++ )                                                                 \n"
"               {                                                                                              \n"
"                   float a =0.0;                                                                              \n"
"                   int adressQS = (j*shape+k)*nEq*nEq;                                                        \n"
"                   unsigned int elemC = connectTable[ tx * shape + k ]*nEq+l;                                 \n"
"                                                                                                              \n"
"                   for(int m = 0; m<nEq;m++)                                                                  \n"
"                       a += Ki[adressQS+l*nEq+m]*help[adressDer+m];                                           \n"
"                   phiHN[(j*shape+k)*nEq+l]=a;                                                                \n"
"               }                                                                                              \n"
"           }                                                                                                  \n"
"        }                                                                                                     \n"
"                                                                                                              \n"
"        for(unsigned int j = get_local_id(0);j< shape;j+= get_local_size(0) )                                 \n"
"        {                                                                                                     \n"
"           for( int k = 0; k < quad; k++ )                                                                    \n"
"           {                                                                                                  \n"
"               waveSpeed[tx*shape+j] += wS[k*shape+j];                                                        \n"
"               for( int l = 0; l < nEq; l++ )                                                                 \n"
"                  phi[(tx*shape+j)*nEq+l] +=  phiH[(k*shape+j)*nEq+l]+0.001*phiHN[(k*shape+j)*nEq+l];         \n"
"           }                                                                                                  \n"
"        }                                                                                                     \n"
"     }                                                                                                        \n"

"    }                                                                                                         \n"
};
