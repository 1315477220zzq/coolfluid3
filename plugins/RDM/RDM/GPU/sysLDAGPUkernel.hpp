// OpenCL Kernel
char* GPUSource =
{
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable \n"
"    void AtomicAdd(__global float *val, const float delta )                                                \n"
"    {                                                                                                      \n"
"        union { float f; unsigned int i; } oldVal;                                                         \n"
"        union { float f; unsigned int i; } newVal;                                                         \n"
"                                                                                                           \n"
"        do                                                                                                 \n"
"        {                                                                                                  \n"
"            oldVal.f = *val;                                                                               \n"
"            newVal.f = oldVal.f + delta;                                                                   \n"
"        }                                                                                                  \n"
"        while (atom_cmpxchg((__global unsigned int *)val, oldVal.i, newVal.i) != oldVal.i);                \n"
"    }                                                                                                      \n"
"    __kernel void interpolation(__global float* phi, __global float* waveSpeed,                            \n"
"                                __global float* A, __global float* A_ksi, __global float* A_eta,           \n"
"                                __global float* weights,                                                   \n"
"                                __global float* X_node, __global float* U_node,                            \n"
"                                __global uint* connectTable,                                               \n"
"                                int shape, int quad, int dim, int elem, int nEq,                           \n"
"                                __local float* X_shape,  __local float* U_shape,                           \n"
"                                __local float* X_quad,   __local float* X_ksi, __local float* X_eta,       \n"
"                                __local float* U_quad,   __local float* jq,    __local float* Rv,          \n"
"                                __local float* Lv,       __local float* Dv,    __local float* Af,          \n"
"                                __local float* Bf,       __local float* Ki,    __local float* invKi,       \n"
"                                __local float* sumLplus, __local float* dudx,  __local float* dudy,        \n"
"                                __local float* LU,       __local float* LUwq,  __local float* help,        \n"
"                                __local float* phiH,     __local float* phiHN )                            \n"
"    {                                                                                                      \n"
"     for( uint tx = 0; tx < elements; tx++ )                                                               \n"
"     {                                                                                                     \n"
"        // connection data from the table to the real element                                              \n"
"                                                                                                           \n"
"        for(unsigned int j = 0;j< shape;j++ )                                                              \n"
"        {                                                                                                  \n"
"                       uint adress = connectTable[ tx * shape + j ];                                       \n"
"                       for( unsigned int k = 0; k < dim; k++)                                              \n"
"                       {                                                                                   \n"
"                           X_shape[ j*dim + k] = X_node[ adress*dim + k ];                                 \n"
"                       }                                                                                   \n"
"                       for( unsigned int k = 0; k < nEq; k++)                                              \n"
"                       {                                                                                   \n"
"                           U_shape[ j*nEq + k] = U_node[ adress*nEq + k ];                                 \n"
"                       }                                                                                   \n"
"        }                                                                                                  \n"
"                                                                                                           \n"
"       //  interpolation data from shape to quadreture points                                              \n"
"                                                                                                           \n"
"       // float X_quad[quad*dim],X_ksi[quad*dim],X_eta[quad*dim], U_quad[quad*nEq];                        \n"
"       // float jq[quad];                                                                                  \n"
"       // float Rv[nEq*nEq*quad], Lv[nEq*nEq*quad], Dv[nEq*quad], Af[nEq*nEq*quad], Bf[nEq*nEq*quad];      \n"
"       // float Ki[nEq*nEq*quad*shape], invKi[nEq*nEq*quad*shape];                                         \n"
"       // float sumLplus[nEq*nEq*quad], dudx[nEq*quad], dudy[nEq*quad], LU[nEq*quad];                      \n"
"       // float LUwq[nEq*quad], help[nEq*quad];                                                            \n"
"                                                                                                           \n"
"        float gamma = 1.4;                                                                                 \n"
"        float R = 287.058;                                                                                 \n"
"                                                                                                           \n"
"        for(unsigned int j = 0;j< quad;j++ )                                                               \n"
"        {                                                                                                  \n"
"           for( unsigned int k = 0; k < dim; k++ )                                                         \n"
"           {                                                                                               \n"
"                unsigned int elemC =  j * dim + k;                                                         \n"
"                                                                                                           \n"
"                float value = 0;                                                                           \n"
"                float value1 = 0;                                                                          \n"
"                float value2 = 0;                                                                          \n"
"                                                                                                           \n"
"                for( unsigned int l = 0; l < shape; l++ )                                                  \n"
"                {                                                                                          \n"
"                    unsigned int elemA = j * shape + l;                                                    \n"
"                    unsigned int elemB = l * dim + k;                                                      \n"
"                                                                                                           \n"
"                    value += A_inter[elemA] * X_shape[elemB];                                              \n"
"                    value1 += A_ksi[elemA] * X_shape[elemB];                                               \n"
"                    value2 += A_eta[elemA] * X_shape[elemB];                                               \n"
"                }                                                                                          \n"
"                X_quad[elemC] = value;                                                                     \n"
"                X_ksi[elemC] =  value1;                                                                    \n"
"                X_eta[elemC] =  value2;                                                                    \n"
"           }                                                                                               \n"
"                                                                                                           \n"
"           jq[j] = X_ksi[j * dim] * X_eta[j*dim+1] - X_ksi[j * dim+1] * X_eta[j*dim];                      \n"
"                                                                                                           \n"
"                                                                                                           \n"
"                                                                                                           \n"
"           for( unsigned int k = 0; k < nEq; k++ )                                                         \n"
"           {                                                                                               \n"
"                unsigned int elemC =  j * nEq + k;                                                         \n"
"                                                                                                           \n"
"                float value = 0;                                                                           \n"
"                                                                                                           \n"
"                for( unsigned int l = 0; l < shape; l++ )                                                  \n"
"                {                                                                                          \n"
"                    unsigned int elemA = j * shape + l;                                                    \n"
"                    unsigned int elemB = l * nEq + k;                                                      \n"
"                                                                                                           \n"
"                    value += A_inter[elemA] * U_shape[elemB];                                              \n"
"                }                                                                                          \n"
"                U_quad[elemC] = value;                                                                     \n"
"           }                                                                                               \n"
"                                                                                                           \n"
"           // set matrix Ki                                                                                \n"
"                                                                                                           \n"
"           // compute properties                                                                           \n"
"                                                                                                           \n"
"           float rho = U_quad[j*nEq];                                                                      \n"
"           float rhoU = U_quad[j*nEq + 1];                                                                 \n"
"           float rhoV = U_quad[j*nEq + 2];                                                                 \n"
"           float rhoE = U_quad[j*nEq + 3];                                                                 \n"
"           float u = rhoU / rho;                                                                           \n"
"           float v = rhoV / rho;                                                                           \n"
"           float uuvv = u*u + v*v;                                                                         \n"
"           float H = gamma * rhoE / rho - 0.5 * ( gamma - 1 ) * uuvv;                                      \n"
"           float a = sqrt((gamma-1)*(H-0.5*uuvv));                                                         \n"
"           float T = a*a/(gamma*R);                                                                        \n"
"           float p = rho * R * T;                                                                          \n"
"           float E  = H-p / rho;                                                                           \n"
"           float half_gm1_v2 = 0.5 * (gamma - 1 ) * uuvv;                                                  \n"
"                                                                                                           \n"
"           int adressQ = j*nEq*nEq;                                                                        \n"
"           int adressDer = j*nEq;                                                                          \n"
"           for( int k = 0; k < 16; k++ )                                                                   \n"
"           {                                                                                               \n"
"               sumLplus[adressQ+k] = 0;                                                                    \n"
"           }                                                                                               \n"
"           for( int k = 0; k < nEq; k++)                                                                   \n"
"           {                                                                                               \n"
"               dudx[adressDer + k] = 0.0;                                                                  \n"
"               dudy[adressDer + k] = 0.0;                                                                  \n"
"                                                                                                           \n"
"           }                                                                                               \n"
"                                                                                                           \n"
"           for( int k = 0; k < shape; k++ )                                                                \n"
"           {                                                                                               \n"
"               unsigned int elemMatrix = j * shape + k;                                                    \n"
"               unsigned int elemA      = j * dim;                                                          \n"
"                                                                                                           \n"
"               float nx =  A_ksi[elemMatrix] * X_eta[elemA+1] - A_eta[elemMatrix] * X_ksi[elemA+1];//gradX \n"
"               float ny = -A_ksi[elemMatrix] * X_eta[elemA] + A_eta[elemMatrix] * X_ksi[elemA];//gradY     \n"
"                                                                                                           \n"
"               for( int l = 0; l < nEq; l++ )                                                              \n"
"               {                                                                                           \n"
"                   unsigned int elemB = l * nEq + k;                                                       \n"
"                   dudx[adressDer + k] += nx*U_shape[elemB];                                               \n"
"                   dudy[adressDer + k] += ny*U_shape[elemB];                                               \n"
"               }                                                                                           \n"
"                                                                                                           \n"
"               float um = u * nx + v * ny;                                                                 \n"
"               float ra = 0.5 * rho / a;                                                                   \n"
"               float coeffM2 = half_gm1_v2 / (a*a);                                                        \n"
"               float uDivA = (gamma -1) * u / a;                                                           \n"
"               float vDivA = (gamma -1) * v / a;                                                           \n"
"               float gm1_ov_rhoa = (gamma -1) / a;                                                         \n"
"                                                                                                           \n"
"               Rv[adressQ]    = 1;        Rv[adressQ+1]  = 0.0;             Rv[adressQ+2]  = ra;            Rv[adressQ+3]  = ra;                                      \n"
"               Rv[adressQ+4]  = u;        Rv[adressQ+5]  = rho*ny;          Rv[adressQ+6]  = ra * (u+a*nx); Rv[adressQ+7]  = ra * (u-a*nx);                           \n"
"               Rv[adressQ+8]  = v;        Rv[adressQ+9]  = -rho*nx;         Rv[adressQ+10] = ra * (v+a*ny); Rv[adressQ+11] = ra * (v-a*ny);                           \n"
"               Rv[adressQ+12] = 0.5*uuvv; Rv[adressQ+13] = rho*(u*ny-v*nx); Rv[adressQ+14] = ra * (H+a*um); Rv[adressQ+15] = ra * (H-a*um);                           \n"
"                                                                                                                                                                      \n"
"               Lv[adressQ]    = 1-coeffM2;                    Lv[adressQ+1]  = uDivA / a;        Lv[adressQ+2]  = vDivA / a;        Lv[adressQ+3] = (gamma-1)/(a*a);  \n"
"               Lv[adressQ+4]  = ( v*nx-u*ny ) / rho;          Lv[adressQ+5]  = ny/rho;           Lv[adressQ+6]  = -nx / rho;        Lv[adressQ+7] = 0.0;              \n"
"               Lv[adressQ+8]  = a / rho * (coeffM2 - um / a); Lv[adressQ+9]  = (nx-uDivA) / rho; Lv[adressQ+10] = (ny-vDivA) / rho; Lv[adressQ+11] = gm1_ov_rhoa;     \n"
"               Lv[adressQ+12] = a / rho * (coeffM2 + um / a); Lv[adressQ+13] = (nx+uDivA) / rho; Lv[adressQ+14] = (ny+vDivA) / rho; Lv[adressQ+15] = gm1_ov_rhoa;     \n"
"                                                                                                                            \n"
"               //Dv[j*nEq] = max(um,0); Dv[j*nEq+1] = max(um,0); Dv[j*nEq+2] = max(um+a,0); Dv[j*nEq+3] =max(um-a,0);       \n"
"               if (um<0) { Dv[j*nEq] = 0; Dv[j*nEq+1] = 0; } else { Dv[j*nEq] = um; Dv[j*nEq+1] = um; }                     \n"
"               if (um+a<0) Dv[j*nEq+2]=0; else Dv[j*nEq+2]=um+a;                                                            \n"
"               if (um-a<0) Dv[j*nEq+3]=0; else Dv[j*nEq+3]=um-a;                                                            \n"
"                                                                                                           \n"
"               int adressQS = (j*shape+k)*nEq*nEq;                                                         \n"
"                                                                                                           \n"
"               for( int l = 0; l < nEq*nEq; l++ )                                                          \n"
"                   Ki[adressQS+l] = 0;                                                                     \n"
"               for( int l = 0; l < nEq; l++ )                                                              \n"
"                  for( int m = 0; m < nEq; m++ )                                                           \n"
"                     for( int n = 0; n < nEq; n++ )                                                        \n"
"                           Ki[adressQS+l*nEq+m] += Rv[adressQ+l*nEq+n ] * Dv[j*nEq+n] * Lv[adressQ+m+n*nEq ]; \n"
"               for( int l = 0; l < nEq*nEq; l++ )                                                             \n"
"                   sumLplus[adressQ+l] += Ki[adressQS+l];                                                     \n"
"            }                                                                                                 \n"
"                                                                                                              \n"
"           float detKi = sumLplus[adressQ]  *(sumLplus[adressQ+5]*sumLplus[adressQ+10]*sumLplus[adressQ+15] + sumLplus[adressQ+6]*sumLplus[adressQ+11]*sumLplus[adressQ+13] + sumLplus[adressQ+7]*sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+5]*sumLplus[adressQ+11]*sumLplus[adressQ+14] - sumLplus[adressQ+6]*sumLplus[adressQ+9] *sumLplus[adressQ+15] - sumLplus[adressQ+7]*sumLplus[adressQ+10]*sumLplus[adressQ+13] )  \n"
"                       + sumLplus[adressQ+1]*(sumLplus[adressQ+4]*sumLplus[adressQ+11]*sumLplus[adressQ+14] + sumLplus[adressQ+6]*sumLplus[adressQ+8] *sumLplus[adressQ+15] + sumLplus[adressQ+7]*sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+4]*sumLplus[adressQ+10]*sumLplus[adressQ+15] - sumLplus[adressQ+6]*sumLplus[adressQ+11]*sumLplus[adressQ+12] - sumLplus[adressQ+7]*sumLplus[adressQ+8] *sumLplus[adressQ+14] )  \n"
"                       + sumLplus[adressQ+2]*(sumLplus[adressQ+4]*sumLplus[adressQ+9] *sumLplus[adressQ+15] + sumLplus[adressQ+5]*sumLplus[adressQ+11]*sumLplus[adressQ+12] + sumLplus[adressQ+7]*sumLplus[adressQ+8] *sumLplus[adressQ+13] - sumLplus[adressQ+4]*sumLplus[adressQ+11]*sumLplus[adressQ+13] - sumLplus[adressQ+5]*sumLplus[adressQ+8] *sumLplus[adressQ+15] - sumLplus[adressQ+7]*sumLplus[adressQ+9] *sumLplus[adressQ+12] )  \n"
"                       + sumLplus[adressQ+3]*(sumLplus[adressQ+4]*sumLplus[adressQ+10]*sumLplus[adressQ+13] + sumLplus[adressQ+5]*sumLplus[adressQ+8] *sumLplus[adressQ+14] + sumLplus[adressQ+6]*sumLplus[adressQ+9] *sumLplus[adressQ+12] - sumLplus[adressQ+4]*sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+5]*sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+6]*sumLplus[adressQ+8] *sumLplus[adressQ+13] ); \n"
"                                                                                                                                                                                                                                                                                                                                                                                                                                               \n"
"           invKi[adressQ]    = 1 / detKi * ( sumLplus[adressQ+5]*(sumLplus[adressQ+10]*sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+14]) + sumLplus[adressQ+6]*(sumLplus[adressQ+11]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+15]) + sumLplus[adressQ+7]*(sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+1]  = 1 / detKi * ( sumLplus[adressQ+1]*(sumLplus[adressQ+11]*sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+15]) + sumLplus[adressQ+2]*(sumLplus[adressQ+9] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+13]) + sumLplus[adressQ+3]*(sumLplus[adressQ+10]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+14]) );                                                        \n"
"           invKi[adressQ+2]  = 1 / detKi * ( sumLplus[adressQ+1]*(sumLplus[adressQ+6] *sumLplus[adressQ+15] - sumLplus[adressQ+7] *sumLplus[adressQ+14]) + sumLplus[adressQ+2]*(sumLplus[adressQ+7] *sumLplus[adressQ+13] - sumLplus[adressQ+5] *sumLplus[adressQ+15]) + sumLplus[adressQ+3]*(sumLplus[adressQ+5] *sumLplus[adressQ+14] - sumLplus[adressQ+6] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+3]  = 1 / detKi * ( sumLplus[adressQ+1]*(sumLplus[adressQ+7] *sumLplus[adressQ+10] - sumLplus[adressQ+6] *sumLplus[adressQ+11]) + sumLplus[adressQ+2]*(sumLplus[adressQ+5] *sumLplus[adressQ+11] - sumLplus[adressQ+7] *sumLplus[adressQ+9])  + sumLplus[adressQ+3]*(sumLplus[adressQ+6] *sumLplus[adressQ+9]  - sumLplus[adressQ+5] *sumLplus[adressQ+10]) );                                                        \n"
"           invKi[adressQ+4]  = 1 / detKi * ( sumLplus[adressQ+4]*(sumLplus[adressQ+11]*sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+15]) + sumLplus[adressQ+6]*(sumLplus[adressQ+8] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+12]) + sumLplus[adressQ+7]*(sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+14]) );                                                        \n"
"           invKi[adressQ+5]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+10]*sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+14]) + sumLplus[adressQ+2]*(sumLplus[adressQ+11]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+15]) + sumLplus[adressQ+3]*(sumLplus[adressQ+8] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+6]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+7] *sumLplus[adressQ+14] - sumLplus[adressQ+6] *sumLplus[adressQ+15]) + sumLplus[adressQ+2]*(sumLplus[adressQ+4] *sumLplus[adressQ+15] - sumLplus[adressQ+7] *sumLplus[adressQ+12]) + sumLplus[adressQ+3]*(sumLplus[adressQ+6] *sumLplus[adressQ+12] - sumLplus[adressQ+4] *sumLplus[adressQ+14]) );                                                        \n"
"           invKi[adressQ+7]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+6] *sumLplus[adressQ+11] - sumLplus[adressQ+7] *sumLplus[adressQ+10]) + sumLplus[adressQ+2]*(sumLplus[adressQ+7] *sumLplus[adressQ+8]  - sumLplus[adressQ+4] *sumLplus[adressQ+11]) + sumLplus[adressQ+3]*(sumLplus[adressQ+4] *sumLplus[adressQ+10] - sumLplus[adressQ+6] *sumLplus[adressQ+8]) );                                                         \n"
"           invKi[adressQ+8]  = 1 / detKi * ( sumLplus[adressQ+4]*(sumLplus[adressQ+9] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+13]) + sumLplus[adressQ+5]*(sumLplus[adressQ+11]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+15]) + sumLplus[adressQ+7]*(sumLplus[adressQ+8] *sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+9]  = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+11]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+15]) + sumLplus[adressQ+1]*(sumLplus[adressQ+8] *sumLplus[adressQ+15] - sumLplus[adressQ+11]*sumLplus[adressQ+12]) + sumLplus[adressQ+3]*(sumLplus[adressQ+9] *sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+10] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+5] *sumLplus[adressQ+15] - sumLplus[adressQ+7] *sumLplus[adressQ+13]) + sumLplus[adressQ+1]*(sumLplus[adressQ+7] *sumLplus[adressQ+12] - sumLplus[adressQ+4] *sumLplus[adressQ+15]) + sumLplus[adressQ+3]*(sumLplus[adressQ+4] *sumLplus[adressQ+13] - sumLplus[adressQ+5] *sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+11] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+7] *sumLplus[adressQ+9]  - sumLplus[adressQ+5] *sumLplus[adressQ+11]) + sumLplus[adressQ+1]*(sumLplus[adressQ+4] *sumLplus[adressQ+11] - sumLplus[adressQ+7] *sumLplus[adressQ+8])  + sumLplus[adressQ+3]*(sumLplus[adressQ+5] *sumLplus[adressQ+8]  - sumLplus[adressQ+4] *sumLplus[adressQ+9]) );                                                         \n"
"           invKi[adressQ+12] = 1 / detKi * ( sumLplus[adressQ+4]*(sumLplus[adressQ+10]*sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+14]) + sumLplus[adressQ+5]*(sumLplus[adressQ+8] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+12]) + sumLplus[adressQ+6]*(sumLplus[adressQ+9] *sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+13] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+9] *sumLplus[adressQ+14] - sumLplus[adressQ+10]*sumLplus[adressQ+13]) + sumLplus[adressQ+1]*(sumLplus[adressQ+10]*sumLplus[adressQ+12] - sumLplus[adressQ+8] *sumLplus[adressQ+14]) + sumLplus[adressQ+2]*(sumLplus[adressQ+8] *sumLplus[adressQ+13] - sumLplus[adressQ+9] *sumLplus[adressQ+12]) );                                                        \n"
"           invKi[adressQ+14] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+6] *sumLplus[adressQ+13] - sumLplus[adressQ+5] *sumLplus[adressQ+14]) + sumLplus[adressQ+1]*(sumLplus[adressQ+4] *sumLplus[adressQ+14] - sumLplus[adressQ+6] *sumLplus[adressQ+12]) + sumLplus[adressQ+2]*(sumLplus[adressQ+5] *sumLplus[adressQ+12] - sumLplus[adressQ+4] *sumLplus[adressQ+13]) );                                                        \n"
"           invKi[adressQ+15] = 1 / detKi * ( sumLplus[adressQ]  *(sumLplus[adressQ+5] *sumLplus[adressQ+10] - sumLplus[adressQ+6] *sumLplus[adressQ+9])  + sumLplus[adressQ+1]*(sumLplus[adressQ+6] *sumLplus[adressQ+8]  - sumLplus[adressQ+4] *sumLplus[adressQ+10]) + sumLplus[adressQ+2]*(sumLplus[adressQ+4] *sumLplus[adressQ+9]  - sumLplus[adressQ+5] *sumLplus[adressQ+8]) );                                                         \n"
"                                                                                                                                                     \n"
"           Af[adressQ]    = 0;                  Af[adressQ+1]  = 1.0;               Af[adressQ+2]  = 0.0;            Af[adressQ+3] = 0.0;             \n"
"           Af[adressQ+4]  = half_gm1_v2 -u*u;   Af[adressQ+5]  = -(gamma - 3)*u;    Af[adressQ+6]  = -(gamma-1)*v;   Af[adressQ+7] =( gamma - 1 );   \n"
"           Af[adressQ+8]  = -u*v;               Af[adressQ+9]  = v;                 Af[adressQ+10] = u;              Af[adressQ+11] = 0.0;           \n"
"           Af[adressQ+12] = ( half_gm1_v2-H)*u; Af[adressQ+13] = -(gamma-1)*u*u +H; Af[adressQ+14] = -(gamma-1)*u*v; Af[adressQ+15] = gamma * u;     \n"
"                                                                                                                                                     \n"
"           Bf[adressQ]    = 0;                  Bf[adressQ+1]  = 0.0;            Bf[adressQ+2]  = 1.0;               Bf[adressQ+3] = 0.0;            \n"
"           Bf[adressQ+4]  = -u*v;               Bf[adressQ+5]  = v;              Bf[adressQ+6]  = u;                 Bf[adressQ+7] = 0.0;            \n"
"           Bf[adressQ+8]  = half_gm1_v2 -v*v;   Bf[adressQ+9]  = -(gamma-1)*u;   Bf[adressQ+10] = -(gamma - 3)*v;    Bf[adressQ+11] =( gamma - 1 );  \n"
"           Bf[adressQ+12] = ( half_gm1_v2-H)*v; Bf[adressQ+13] = -(gamma-1)*u*v; Bf[adressQ+14] = -(gamma-1)*v*v +H; Bf[adressQ+15] = gamma *v;      \n"
"                                                                                                                                                     \n"
"           for(int k = 0; k < nEq; k++ )                                                                      \n"
"           {                                                                                                  \n"
"               float aux = 0;                                                                                 \n"
"               float buy = 0;                                                                                 \n"
"                                                                                                              \n"
"               for( int l=0; l < nEq; l++ )                                                                   \n"
"               {                                                                                              \n"
"                   aux +=Af[adressQ+k*nEq+l]*dudx[adressDer+l];                                               \n"
"                   buy +=Bf[adressQ+k*nEq+l]*dudy[adressDer+l];                                               \n"
"               }                                                                                              \n"
"                                                                                                              \n"
"               LU[j*nEq+k] = aux+buy;                                                                         \n"
"           }                                                                                                  \n"
"                                                                                                              \n"
"           for(int k = 0; k < nEq; k++ )                                                                      \n"
"           {                                                                                                  \n"
"               float a = 0;                                                                                   \n"
"                                                                                                              \n"
"               for( int l=0; l < nEq; l++ )                                                                   \n"
"                  a +=invKi[adressQ+k*nEq+l]*LU[adressDer+l]*weights[j];                                      \n"
"               LUwq[j*nEq+k] = a;                                                                             \n"
"           }                                                                                                  \n"
"                                                                                                              \n"
"           for(int k = 0; k < shape; k++ )                                                                    \n"
"           {                                                                                                  \n"
"                                                                                                              \n"
"               int adressQS = (j*shape+k)*nEq*nEq;                                                            \n"
"               for( int l=0; l < nEq; l++ )                                                                   \n"
"               {                                                                                              \n"
"                   float a = 0;                                                                               \n"
"                   unsigned int elemC = connectTable[ tx * shape + k ]*nEq+l;                                 \n"
"                   for( int m = 0; m < nEq; m++ )                                                             \n"
"                       a +=Ki[adressQS+l*nEq+m]*LUwq[j*nEq+m];                                                \n"
"                   phiH[k*nEq+l] = a;//phi[elemC] += a;                                                       \n"
"               }                                                                                              \n"
"                                                                                                              \n"
"           }                                                                                                  \n"
"                                                                                                              \n"
"           // N disipation                                                                                    \n"
"                                                                                                              \n"
"           for(int k = 0; k<shape;k++)                                                                        \n"
"           {                                                                                                  \n"
"              for( int m = 0; m < nEq; m++ )                                                                  \n"
"                   LUwq[adressDer+m] = 0;                                                                     \n"
"                                                                                                              \n"
"               for(int m = 0; m < shape; m++ )                                                                \n"
"               {                                                                                              \n"
"                   int adressQS = (j*shape+m)*nEq*nEq;                                                        \n"
"                   if( k != m )                                                                               \n"
"                   {                                                                                          \n"
"                       for( int n = 0; n<nEq; n++)                                                            \n"
"                       {                                                                                      \n"
"                           float a = 0;                                                                       \n"
"                           for(int o = 0; o<nEq; o++)                                                         \n"
"                              a+=Ki[adressQS+n*nEq+o]*(U_shape[ k*nEq + o] - U_shape[ m*nEq + o]);            \n"
"                           LUwq[adressDer+n] += a;                                                            \n"
"                       }                                                                                      \n"
"                                                                                                              \n"
"                   }                                                                                          \n"
"               }                                                                                              \n"
"                                                                                                              \n"
"               for( int l = 0; l < nEq; l++ )                                                                 \n"
"               {                                                                                              \n"
"                   float a =0;                                                                                \n"
"                                                                                                              \n"
"                   for(int m = 0; m<nEq;m++)                                                                  \n"
"                       a += invKi[adressQ + l* nEq+m]*LUwq[adressDer+m]*weights[j];                           \n"
"                   help[adressDer+l] =a;                                                                      \n"
"               }                                                                                              \n"
"               for( int l = 0; l < nEq; l++ )                                                                 \n"
"               {                                                                                              \n"
"                   float a =0;                                                                                \n"
"                   int adressQS = (j*shape+k)*nEq*nEq;                                                        \n"
"                   unsigned int elemC = connectTable[ tx * shape + k ]*nEq+l;                                 \n"
"                                                                                                              \n"
"                   for(int m = 0; m<nEq;m++)                                                                  \n"
"                       a += Ki[adressQS+l*nEq+m]*help[adressDer+m];                                           \n"
"                   phiHN[k*nEq+l] = a;//phiN[elemC] += a;                                                     \n"
"               }                                                                                              \n"
"           }                                                                                                  \n"
"        }                                                                                                     \n"
"        for(unsigned int j = 0;j< nEq;j++ )                                                                   \n"
"        {                                                                                                     \n"
"            float sumPhi = 0; float sumPhiN = 0;                                                              \n"
"            for(unsigned int k = 0;k< shape;k++ )                                                             \n"
"            {                                                                                                 \n"
"                sumPhi  += phiH[k*nEq];                                                                       \n"
"                sumPhiN += abs(phiH[k*nEq]+phiHN[k*nEq]);                                                     \n"
"            }                                                                                                 \n"
"            sumPhiN = max(sumPhiN, 1e-8);                                                                     \n"
"            float theta = abs(sumPhi) / sumPhiN;                                                              \n"
"                                                                                                              \n"
"            for(unsigned int k = 0;k< shape;k++ )                                                             \n"
"            {                                                                                                 \n"
"                 unsigned int elemC = connectTable[ tx * shape + k ]*nEq+j;                                   \n"
"                 AtomicAdd( &phi[elemC], phiH[k*nEq]+theta*phiHN[k*nEq] );                                    \n"
"            }                                                                                                 \n"
"        }                                                                                                     \n"
"        float xmin = X_shape[0 ];                                                                             \n"
"        float xmax = X_shape[0 ];                                                                             \n"
"        float ymin = X_shape[1 ];                                                                             \n"
"        float ymax = X_shape[1 ];                                                                             \n"
"        for(unsigned int j = 1;j< shape; j++ )                                                                \n"
"        {                                                                                                     \n"
"             xmin = min( xmin, X_shape[0 ] );                                                                 \n"
"             xmax = max( xmax, X_shape[0 ] );                                                                 \n"
"             ymin = min( ymin, X_shape[ j * dim +1] );                                                        \n"
"             ymax = max( ymax, X_shape[ j * dim +1] );                                                        \n"
"        }                                                                                                     \n"
"        float dx =xmax-xmin;                                                                                  \n"
"        float dy =ymax-ymin;                                                                                  \n"
"        for(unsigned int j = get_local_id(0);j< shape;j+= get_local_size(0) )                                 \n"
"        {                                                                                                     \n"
"            unsigned int elemC = connectTable[ tx * shape + j ];                                              \n"
"            AtomicAdd( &waveSpeed[elemC], sqrt( dx*dx +dy*dy ) );                                             \n"
"        }                                                                                                     \n"
"     }                                                                                                        \n"
"    }                                                                                                         \n"
};
